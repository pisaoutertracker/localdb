<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>All Module Tests</title>
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <link rel="stylesheet" type="text/css" href="https://cdn.datatables.net/v/dt/dt-1.10.20/datatables.min.css"/>
    <script type="text/javascript" src="https://cdn.datatables.net/v/dt/dt-1.10.20/datatables.min.js"></script>
    <style>
        .container { max-width: 100%; margin: 0 auto; padding: 20px; }
        .plot-selector {
            margin: 20px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 4px;
            display: flex;
            align-items: center;
        }
        .plot-image {
            max-width: 400px;
            cursor: pointer;
        }
        .plot-image:hover {
            transform: scale(1.05);
            transition: transform 0.2s;
        }
        .select-all-container {
            margin: 10px 0;
        }
        .plots-container {
            display: flex;
            flex-direction: row;
            flex-wrap: nowrap;
            overflow-x: auto;
            width: 100%;
        }
        .dataTables_wrapper {
            overflow-x: auto;
        }
        #testsTable {
            width: 100% !important;
        }
        .run-info {
            display: flex;
            flex-direction: column;
        }
        .run-number {
            font-weight: bold;
        }
        .run-date {
            font-size: 0.9em;
            color: #666;
        }
        .run-type {
            font-size: 0.9em;
            color: #666;
        }
        .run-results {
            font-size: 0.9em;
            margin-top: 2px;
        }
        .run-results a {
            color: #0066cc;
            text-decoration: none;
        }
        .run-results a:hover {
            text-decoration: underline;
        }
        .session-info {
            display: flex;
            flex-direction: column;
            width: 200px;
            word-wrap: break-word;
            white-space: normal;
        }
        .session-operator {
            font-weight: bold;
        }
        .session-description {
            font-size: 0.9em;
            color: #666;
        }
        .loading {
            text-align: center;
            padding: 50px;
            font-size: 18px;
            color: #666;
        }
        .error {
            background-color: #fff0f0;
            color: #c00;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            border-left: 4px solid #c00;
            display: none;
        }
        .pass-badge {
            display: inline-block;
            padding: 2px 6px;
            background-color: #4CAF50;
            color: white;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .fail-badge {
            display: inline-block;
            padding: 2px 6px;
            background-color: #f44336;
            color: white;
            border-radius: 4px;
            font-size: 0.8em;
            margin-left: 5px;
        }
        .back-button {
            display: inline-block;
            margin-bottom: 20px;
            padding: 10px 15px;
            background-color: #0066cc;
            color: white;
            text-decoration: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .back-button:hover {
            background-color: #0055aa;
        }
        .toggle-default-sessions {
            margin: 10px 0;
            display: flex;
            align-items: center;
        }
        .toggle-default-sessions input {
            margin-right: 8px;
        }
        .noise-stats {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .noise-component {
            margin-bottom: 6px;
            border-left: 3px solid #eee;
            padding-left: 8px;
        }
        .noise-component-title {
            font-weight: bold;
            margin-bottom: 2px;
        }
        .noise-stat-row {
            font-size: 0.9em;
        }
        .hidden-session {
            display: none;
        }
        .temperature-info {
            margin-top: 4px;
            font-size: 0.85em;
            color: #333;
            display: flex;
            align-items: center;
        }
        .temperature-label {
            font-weight: bold;
            margin-right: 5px;
        }
        .temperature-value {
            color: #0066cc;
        }
        .temperature-value-unknown {
            color: #999;
            font-style: italic;
        }
        .pagination-controls {
            margin: 20px 0;
            text-align: center;
        }
        .pagination-controls button {
            padding: 8px 15px;
            margin: 0 5px;
            background: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .pagination-controls button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .pagination-controls button.active {
            background: #0066cc;
            color: white;
            border-color: #0055aa;
        }
        .pagination-info {
            margin: 10px 0;
            font-size: 0.9em;
            color: #666;
        }
        .plot-column {
            display: inline-block;
            margin-right: 10px;
            vertical-align: top;
        }
        .plot-header {
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
        }
        .module-name {
            color: #0066cc;
            cursor: pointer;
            text-decoration: underline;
        }
        .module-name:hover {
            color: #004d99;
        }
        .selected-test {
            background-color: #e6f3ff !important;
        }
        .module-link {
            color: #0066cc;
            text-decoration: none;
            font-weight: bold;
        }
        .module-link:hover {
            text-decoration: underline;
        }
        .search-container {
            margin: 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .search-input {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            flex-grow: 1;
            max-width: 300px;
        }
        .search-button {
            padding: 8px 15px;
            background-color: #0066cc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .search-button:hover {
            background-color: #0055aa;
        }
        .page-length-selector {
            margin-left: 20px;
            display: flex;
            align-items: center;
        }
        .page-length-selector select {
            margin-left: 10px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .run-type-filter-container {
            margin: 10px 0;
            padding: 10px;
            background: #f9f9f9;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        .run-type-filter-container label {
            margin-right: 15px;
            display: inline-block;
        }
        .run-type-filter-container input[type="checkbox"] {
            margin-right: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>All Module Tests</h2>
        
        <div id="loading" class="loading">Loading module test data...</div>
        <div id="error" class="error"></div>
        
        <div id="content" style="display: none;">
            <div class="search-container">
                <input type="text" id="searchInput" class="search-input" placeholder="Search test names...">
                <button id="searchButton" class="search-button">Search</button>
                <div class="page-length-selector">
                    <label for="pageLengthSelect">Items per page:</label>
                    <select id="pageLengthSelect">
                        <option value="1">1</option>
                        <option value="10">10</option>
                        <option value="25" selected>25</option>
                        <option value="100">100</option>
                    </select>
                </div>
            </div>

            <!-- Add Run Type Filter Container -->
            <div id="runTypeFilterContainer" class="run-type-filter-container">
                <strong>Filter by Run Type:</strong>
                <!-- Checkboxes will be added here dynamically -->
            </div>

            <div class="plot-selectors-container">
                <div class="plot-selector" id="plotSelector1">
                    <div>
                        <label for="plotType1">Select Plot Type:</label>
                        <select id="plotType1" class="plot-type-select">
                                                <option value="MPAtoCIC_PatternMatchingErrorRate_Hybrid0">MPA tp CIC Pattern Matching Error Rate Hybrid 0</option>
                        <option value="MPAtoCIC_PatternMatchingErrorRate_Hybrid1">MPA tp CIC Pattern Matching Error Rate Hybrid 1</option>
                            <option value="VTRx_LightYieldScan_OpticalGroup1">Optical Power</option>
                            <option value="StripHybridHits_Hybrid0">Common Mode SSA Hybrid 0</option>
                            <option value="StripHybridHits_Hybrid1">Common Mode SSA Hybrid 1</option>
                            <option value="2DPixelNoise_Hybrid0_MPAMergedMPA">2D Pixel Noise Hybrid 0 MPA Merged</option>
                            <option value="2DPixelNoise_Hybrid1_MPAMergedMPA">2D Pixel Noise Hybrid 1 MPA Merged</option>
                            <option value="2DPixelNoise_MPAMultipleMPA">2D Pixel Noise MPA Multiple</option>
                            <option value="2DPixelNoiseprojX_Hybrid0_MPAMergedMPA">2D Pixel Noise Projection X Hybrid 0 MPA Merged</option>
                            <option value="2DPixelNoiseprojX_Hybrid1_MPAMergedMPA">2D Pixel Noise Projection X Hybrid 1 MPA Merged</option>
                            <option value="2DPixelNoiseprojY_Hybrid0_MPAMergedMPA">2D Pixel Noise Projection Y Hybrid 0 MPA Merged</option>
                            <option value="2DPixelNoiseprojY_Hybrid1_MPAMergedMPA">2D Pixel Noise Projection Y Hybrid 1 MPA Merged</option>
                            <option value="BestCICinputPhases_Hybrid0">Best CIC Input Phases Hybrid 0</option>
                            <option value="BestCICinputPhases_Hybrid1">Best CIC Input Phases Hybrid 1</option>
                            <option value="BitSlipValues_Hybrid0">Bit Slip Values Hybrid 0</option>
                            <option value="BitSlipValues_Hybrid1">Bit Slip Values Hybrid 1</option>
                            <option value="ChannelNoiseDistribution_Hybrid0_MPAMergedMPA">Channel Noise Distribution Hybrid 0 MPA Merged</option>
                            <option value="ChannelNoiseDistribution_Hybrid0_SSAMergedSSA">Channel Noise Distribution Hybrid 0 SSA Merged</option>
                            <option value="ChannelNoiseDistribution_Hybrid1_MPAMergedMPA">Channel Noise Distribution Hybrid 1 MPA Merged</option>
                            <option value="ChannelNoiseDistribution_Hybrid1_SSAMergedSSA">Channel Noise Distribution Hybrid 1 SSA Merged</option>
                            <option value="ChannelNoiseDistribution_MPAMultipleMPA">Channel Noise Distribution MPA Multiple</option>
                            <option value="ChannelNoiseDistribution_SSAMultipleSSA">Channel Noise Distribution SSA Multiple</option>
                            <option value="ChannelPedestalDistribution_Hybrid0_MPAMergedMPA">Channel Pedestal Distribution Hybrid 0 MPA Merged</option>
                            <option value="ChannelPedestalDistribution_Hybrid0_SSAMergedSSA">Channel Pedestal Distribution Hybrid 0 SSA Merged</option>
                            <option value="ChannelPedestalDistribution_Hybrid1_MPAMergedMPA">Channel Pedestal Distribution Hybrid 1 MPA Merged</option>
                            <option value="ChannelPedestalDistribution_Hybrid1_SSAMergedSSA">Channel Pedestal Distribution Hybrid 1 SSA Merged</option>
                            <option value="ChannelPedestalDistribution_MPAMultipleMPA">Channel Pedestal Distribution MPA Multiple</option>
                            <option value="ChannelPedestalDistribution_SSAMultipleSSA">Channel Pedestal Distribution SSA Multiple</option>
                            <option value="CICinputPhaseHistogram_Hybrid0">CIC Input Phase Histogram Hybrid 0</option>
                            <option value="CICinputPhaseHistogram_Hybrid1">CIC Input Phase Histogram Hybrid 1</option>
                            <option value="CICwordAlignmentDelay_Hybrid0">CIC Word Alignment Delay Hybrid 0</option>
                            <option value="CICwordAlignmentDelay_Hybrid1">CIC Word Alignment Delay Hybrid 1</option>
                            <option value="CombinedNoisePlot">Combined Noise Plot</option>
                            <option value="HybridNoiseDistribution_Hybrid0">Hybrid Noise Distribution Hybrid 0</option>
                            <option value="HybridNoiseDistribution_Hybrid1">Hybrid Noise Distribution Hybrid 1</option>
                            <option value="HybridPixelNoiseDistribution_Hybrid0">Hybrid Pixel Noise Distribution Hybrid 0</option>
                            <option value="HybridPixelNoiseDistribution_Hybrid1">Hybrid Pixel Noise Distribution Hybrid 1</option>
                            <option value="HybridStripNoiseDistribution_Hybrid0">Hybrid Strip Noise Distribution Hybrid 0</option>
                            <option value="HybridStripNoiseDistribution_Hybrid1">Hybrid Strip Noise Distribution Hybrid 1</option>
                            <option value="LockingEfficiencyCICinput_Hybrid0">Locking Efficiency CIC Input Hybrid 0</option>
                            <option value="LockingEfficiencyCICinput_Hybrid1">Locking Efficiency CIC Input Hybrid 1</option>
                            <option value="LpGBTinputAlignmentSuccess_OpticalGroup1">LpGBT Input Alignment Success Optical Group 1</option>
                            <option value="LpGBTinputBestPhase_OpticalGroup1">LpGBT Input Best Phase Optical Group 1</option>
                            <option value="LpGBTinputFoundPhasesDistribution_OpticalGroup1">LpGBT Input Found Phases Distribution Optical Group 1</option>
                            <option value="NoiseDistribution_Hybrid0_MPAMergedMPA">Noise Distribution Hybrid 0 MPA Merged</option>
                            <option value="NoiseDistribution_Hybrid0_SSAMergedSSA">Noise Distribution Hybrid 0 SSA Merged</option>
                            <option value="NoiseDistribution_Hybrid1_MPAMergedMPA">Noise Distribution Hybrid 1 MPA Merged</option>
                            <option value="NoiseDistribution_Hybrid1_SSAMergedSSA">Noise Distribution Hybrid 1 SSA Merged</option>
                            <option value="NoiseDistribution_MPAMultipleMPA">Noise Distribution MPA Multiple</option>
                            <option value="NoiseDistribution_SSAMultipleSSA">Noise Distribution SSA Multiple</option>
                            <option value="OccupancyAfterOffsetEqualization_Hybrid0_MPAMergedMPA">Occupancy After Offset Equalization Hybrid 0 MPA Merged</option>
                            <option value="OccupancyAfterOffsetEqualization_Hybrid0_SSAMergedSSA">Occupancy After Offset Equalization Hybrid 0 SSA Merged</option>
                            <option value="OccupancyAfterOffsetEqualization_Hybrid1_MPAMergedMPA">Occupancy After Offset Equalization Hybrid 1 MPA Merged</option>
                            <option value="OccupancyAfterOffsetEqualization_Hybrid1_SSAMergedSSA">Occupancy After Offset Equalization Hybrid 1 SSA Merged</option>
                            <option value="OccupancyAfterOffsetEqualization_MPAMultipleMPA">Occupancy After Offset Equalization MPA Multiple</option>
                            <option value="OccupancyAfterOffsetEqualization_SSAMultipleSSA">Occupancy After Offset Equalization SSA Multiple</option>
                            <option value="Occupancy_Hybrid0_MPAMergedMPA">Occupancy Hybrid 0 MPA Merged</option>
                            <option value="Occupancy_Hybrid0_SSAMergedSSA">Occupancy Hybrid 0 SSA Merged</option>
                            <option value="Occupancy_Hybrid1_MPAMergedMPA">Occupancy Hybrid 1 MPA Merged</option>
                            <option value="Occupancy_Hybrid1_SSAMergedSSA">Occupancy Hybrid 1 SSA Merged</option>
                            <option value="Occupancy_MPAMultipleMPA">Occupancy MPA Multiple</option>
                            <option value="Occupancy_SSAMultipleSSA">Occupancy SSA Multiple</option>
                            <option value="OffsetValues_Hybrid0_MPAMergedMPA">Offset Values Hybrid 0 MPA Merged</option>
                            <option value="OffsetValues_Hybrid0_SSAMergedSSA">Offset Values Hybrid 0 SSA Merged</option>
                            <option value="OffsetValues_Hybrid1_MPAMergedMPA">Offset Values Hybrid 1 MPA Merged</option>
                            <option value="OffsetValues_Hybrid1_SSAMergedSSA">Offset Values Hybrid 1 SSA Merged</option>
                            <option value="PatternMatchingEfficiencyCIC_Hybrid0">Pattern Matching Efficiency CIC Hybrid 0</option>
                            <option value="PatternMatchingEfficiencyCIC_Hybrid1">Pattern Matching Efficiency CIC Hybrid 1</option>
                            <option value="PatternMatchingEfficiency_Hybrid0">Pattern Matching Efficiency Hybrid 0</option>
                            <option value="PatternMatchingEfficiency_Hybrid1">Pattern Matching Efficiency Hybrid 1</option>
                            <option value="PedestalDistribution_Hybrid0_MPAMergedMPA">Pedestal Distribution Hybrid 0 MPA Merged</option>
                            <option value="PedestalDistribution_Hybrid0_SSAMergedSSA">Pedestal Distribution Hybrid 0 SSA Merged</option>
                            <option value="PedestalDistribution_Hybrid1_MPAMergedMPA">Pedestal Distribution Hybrid 1 MPA Merged</option>
                            <option value="PedestalDistribution_Hybrid1_SSAMergedSSA">Pedestal Distribution Hybrid 1 SSA Merged</option>
                            <option value="PedestalDistribution_MPAMultipleMPA">Pedestal Distribution MPA Multiple</option>
                            <option value="PedestalDistribution_SSAMultipleSSA">Pedestal Distribution SSA Multiple</option>
                            <option value="SCurve_Hybrid0_MPAMergedMPA">S-Curve Hybrid 0 MPA Merged</option>
                            <option value="SCurve_Hybrid0_SSAMergedSSA">S-Curve Hybrid 0 SSA Merged</option>
                            <option value="SCurve_Hybrid1_MPAMergedMPA">S-Curve Hybrid 1 MPA Merged</option>
                            <option value="SCurve_Hybrid1_SSAMergedSSA">S-Curve Hybrid 1 SSA Merged</option>
                            <option value="sensor_data_plot">Sensor Data Plot</option>
                            <option value="VplusValue_Hybrid0_MPAMergedMPA">V+ Value Hybrid 0 MPA Merged</option>
                            <option value="VplusValue_Hybrid0_SSAMergedSSA">V+ Value Hybrid 0 SSA Merged</option>
                            <option value="VplusValue_Hybrid1_MPAMergedMPA">V+ Value Hybrid 1 MPA Merged</option>
                            <option value="VplusValue_Hybrid1_SSAMergedSSA">V+ Value Hybrid 1 SSA Merged</option>
                            <option value="WordAlignmentRetryNumbers_Hybrid0">Word Alignment Retry Numbers Hybrid 0</option>
                            <option value="WordAlignmentRetryNumbers_Hybrid1">Word Alignment Retry Numbers Hybrid 1</option>
                        </select>
                    </div>
                    <button class="add-plot-selector" title="Add another plot type">+</button>
                </div>
            </div>

            <div class="select-all-container">
                <input type="checkbox" id="selectAll">
                <label for="selectAll">Select All Tests</label>
            </div>

            <div class="toggle-default-sessions">
                <input type="checkbox" id="hideDefaultSessions" checked>
                <label for="hideDefaultSessions">Hide default sessions (session1)</label>
            </div>

            <table id="testsTable" class="display">
                <thead>
                    <tr>
                        <th>Select</th>
                        <th>Test Name</th>
                        <th>Module</th>
                        <th>Run</th>
                        <th>Session</th>
                        <th>Noise Stats</th>
                        <th>Analysis</th>
                        <th>Plots</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Table data will be loaded dynamically -->
                </tbody>
            </table>

            <div class="pagination-controls">
                <button id="prevPage" disabled>Previous</button>
                <span id="currentPageInfo">Page 1 of 1</span>
                <button id="nextPage">Next</button>
            </div>
            
            <div class="pagination-info">
                <span id="paginationSummary">Showing 1-25 of 0 entries</span>
            </div>
            
            <div id="plotsContainer" class="plots-container" style="display: none;"></div>
        </div>
    </div>

    <script>
        $(document).ready(function() {
            const server = window.location.origin; //current page URL root
            let currentPage = 1;
            let totalPages = 1;
            let totalItems = 0;
            let itemsPerPage = 25;
            let cachedData = {}; // Cache for storing fetched data
            let allTestNames = []; // Store all test names
            let isFromSession1 = []; // Store whether each test is from session1
            let testRunTypesMap = {}; // Map testName -> runType
            let allRunTypesList = []; // Store unique run types
            let selectedRunTypes = new Set(); // Store selected run types for filtering
            let visibleItemsCount = 0; // Track count of visible items after filtering
            let currentTestNames = []; // Store test names for the current page
            let displayData = []; // Data currently displayed in the table
            let selectedTestName = null; // Currently selected test
            const plotCache = {}; // Cache for plot data
            let plotSelectorCount = 1;
            let apiCurrentPage = 1; // Track the current API page we're on
            let searchQuery = ''; // Store the current search query
            let filteredTestNames = []; // Store filtered test names for search results

            // Initialize the page
            loadModuleTestsData();

            // Event listener for search button
            $('#searchButton').on('click', function() {
                performSearch();
            });

            // Event listener for search input (press Enter)
            $('#searchInput').on('keypress', function(e) {
                if (e.which === 13) { // Enter key
                    performSearch();
                }
            });

            // Event listener for page length selector
            $('#pageLengthSelect').on('change', function() {
                itemsPerPage = parseInt($(this).val());
                currentPage = 1; // Reset to first page when changing items per page
                calculateVisibleItems();
                displayCachedOrFetchData();
            });

            // Function to perform search
            function performSearch() {
                searchQuery = $('#searchInput').val().trim().toLowerCase();
                currentPage = 1; // Reset to first page when searching
                
                if (searchQuery === '') {
                    filteredTestNames = []; // Clear filter
                    calculateVisibleItems();
                    displayCachedOrFetchData();
                    return;
                }

                // Filter test names based on search query
                filteredTestNames = allTestNames.filter(testName => 
                    testName.toLowerCase().includes(searchQuery)
                );
                
                console.log(`Search found ${filteredTestNames.length} matching tests`); // Debug log
                
                // Reset pagination
                calculateVisibleItems(); // Recalculate visible items considering search AND run type filters
                
                // Check if we need to load any data for the filtered tests
                let needToFetchData = false;
                // Iterate through the potentially visible tests (search + run type filtered)
                const testList = filteredTestNames; // Start with search results
                let visibleItemIndex = 0;
                for (let i = 0; i < testList.length; i++) {
                    const testName = testList[i];
                    const runType = testRunTypesMap[testName];
                    // Apply run type filter
                    if (selectedRunTypes.size > 0 && !selectedRunTypes.has(runType)) {
                        continue;
                    }
                    // Check cache only for items that pass filters
                    if (!cachedData[testName]) {
                        needToFetchData = true;
                        break;
                    }
                    visibleItemIndex++; // Count only items passing filters
                }

                if (needToFetchData) {
                    loadFilteredTestData(); // This function might need adjustment if it relies solely on filteredTestNames
                } else {
                    displayCachedOrFetchData();
                }
            }
            
            // Load data for filtered tests that are not yet cached
            // Note: This might need refinement if runType filtering significantly changes which pages are needed.
            // The current logic fetches pages based on the original index of *search-filtered* tests.
            function loadFilteredTestData() {
                showLoading();
                
                const pagesToFetch = new Set();
                // Iterate through tests matching the search query
                for (const testName of filteredTestNames) {
                    // Apply run type filter *before* deciding if data needs fetching
                    const runType = testRunTypesMap[testName];
                    if (selectedRunTypes.size > 0 && !selectedRunTypes.has(runType)) {
                        continue; // Skip if filtered out by run type
                    }

                    if (!cachedData[testName]) {
                        const index = allTestNames.indexOf(testName);
                        if (index !== -1) {
                            const pageNum = Math.floor(index / 100) + 1;
                            pagesToFetch.add(pageNum);
                        }
                    }
                }
                
                if (pagesToFetch.size === 0) {
                    hideLoading();
                    displayCachedOrFetchData();
                    return;
                }
                
                console.log(`Need to fetch ${pagesToFetch.size} pages for filtered results`); // Debug log
                
                const pagesArray = Array.from(pagesToFetch).sort((a, b) => a - b);
                let currentPageIndex = 0;
                
                function fetchNextPage() {
                    if (currentPageIndex >= pagesArray.length) {
                        hideLoading();
                        displayCachedOrFetchData();
                        return;
                    }
                    
                    const pageToFetch = pagesArray[currentPageIndex];
                    console.log(`Fetching page ${pageToFetch} for filtered results`); // Debug log
                    
                    $.ajax({
                        url: `${server}/fetch_all_module_test_results`,
                        type: 'GET',
                        data: {
                            page: pageToFetch,
                            per_page: 100
                        },
                        dataType: 'json',
                        success: function(data) {
                            if (data && data.module_tests && data.module_tests.as_dict) {
                                const moduleTests = data.module_tests.as_dict;
                                for (const testName in moduleTests) {
                                    cachedData[testName] = moduleTests[testName];
                                    if (moduleTests[testName].analysis && moduleTests[testName].analysis.analysisFile) {
                                        plotCache[testName] = moduleTests[testName].analysis.analysisFile;
                                    }
                                }
                                currentPageIndex++;
                                fetchNextPage();
                            } else {
                                console.error("Invalid data format:", data);
                                hideLoading();
                                showError("Failed to fetch filtered results data.");
                            }
                        },
                        error: function(xhr, status, error) {
                            console.error("API error:", error);
                            hideLoading();
                            showError(`Failed to fetch filtered results: ${error}`);
                        }
                    });
                }
                fetchNextPage();
            }

            // Add event handler for the add plot selector button
            $('.container').on('click', '.add-plot-selector', function() {
                plotSelectorCount++;
                const newSelectorId = `plotSelector${plotSelectorCount}`;
                
                // Clone the first selector
                const newSelector = $('#plotSelector1').clone();
                newSelector.attr('id', newSelectorId);
                
                // Update the select ID
                newSelector.find('select').attr('id', `plotType${plotSelectorCount}`);
                
                // Replace the add button with remove button for all but the first selector
                newSelector.find('.add-plot-selector').replaceWith(
                    `<button class="remove-plot-selector" data-selector-id="${newSelectorId}" title="Remove this plot type">-</button>`
                );
                
                // Append the new selector
                $('.plot-selectors-container').append(newSelector);
                
                // Update plots if tests are already selected
                updateAllPlots();
            });
            
            // Add event handler for remove plot selector button
            $('.container').on('click', '.remove-plot-selector', function() {
                const selectorId = $(this).data('selector-id');
                $(`#${selectorId}`).remove();
                
                // Update plots
                updateAllPlots();
            });
            
            // Add event handlers for pagination buttons
            $('#prevPage').on('click', function() {
                if (currentPage > 1) {
                    currentPage--;
                    displayCachedOrFetchData();
                }
            });
            
            $('#nextPage').on('click', function() {
                if (currentPage < totalPages) {
                    currentPage++;
                    displayCachedOrFetchData();
                }
            });

            // Handle select all
            $('#selectAll').on('change', function() {
                $('.test-checkbox').prop('checked', this.checked).trigger('change');
            });
            
            // Handle hide default sessions toggle
            $('#hideDefaultSessions').on('change', function() {
                currentPage = 1;
                calculateVisibleItems();
                displayCachedOrFetchData();
            });
            
            // Handle plot type changes
            $('.container').on('change', '.plot-type-select', function() {
                updateAllPlots();
            });
            
            // Load module tests data from the API
            function loadModuleTestsData() {
                showLoading();
                
                // If we have a search query or run type filters, use the filtering logic
                if (searchQuery || selectedRunTypes.size > 0) {
                    // Need to ensure we have the base data (allTestNames, runTypes) before filtering
                    if (!allTestNames.length) {
                        // Fetch page 1 first to get metadata if not already loaded
                        fetchAndProcessPage(1, () => {
                            // After getting metadata, perform the actual filtered fetch/display
                            if (searchQuery) {
                                performSearch();
                            } else {
                                // Just run type filters applied
                                currentPage = 1;
                                calculateVisibleItems();
                                displayCachedOrFetchData();
                            }
                        });
                    } else {
                        // Metadata already loaded, proceed with filtering
                        if (searchQuery) {
                            performSearch();
                        } else {
                            currentPage = 1;
                            calculateVisibleItems();
                            displayCachedOrFetchData();
                        }
                    }
                    return;
                }
                
                // Standard loading logic when no filters are active initially
                fetchAndProcessPage(apiCurrentPage, () => {
                    calculateVisibleItems();
                    filterAndDisplayData();
                    updatePaginationControls();
                    $('#content').show();
                });
            }

            // Helper function to fetch and process a page of data
            function fetchAndProcessPage(pageNumber, callback) {
                $.ajax({
                    url: `${server}/fetch_all_module_test_results`,
                    type: 'GET',
                    data: {
                        page: pageNumber,
                        per_page: 100 // Fetch 100 items per API call for caching
                    },
                    dataType: 'json',
                    success: function(data) {
                        hideLoading();
                        
                        if (data && data.module_tests && data.module_tests.as_dict) {
                            console.log(`Received data for page ${pageNumber}:`, data); // Debug log
                            
                            totalItems = data.pagination.total_items;
                            
                            // Only update metadata if loading for the first time or resetting
                            if (!allTestNames.length || pageNumber === 1) {
                                allTestNames = data.module_tests.all_names || [];
                                isFromSession1 = data.module_tests.is_from_session1 || [];
                                const runTypes = data.module_tests.all_types || []; // Get the full list of types for mapping
                                
                                // *** Use unique_types for the filter list ***
                                allRunTypesList = data.module_tests.unique_types || []; // Get unique run types for filters
                                console.log("API response for unique_types:", data.module_tests.unique_types); // Log unique types
                                
                                // *** Add console log here ***
                                console.log("API response for all_types (for mapping):", data.module_tests.all_types); 
                                
                                // Build the run type map using the full all_types array
                                testRunTypesMap = {};
                                if (allTestNames.length === runTypes.length) {
                                    for (let i = 0; i < allTestNames.length; i++) {
                                        testRunTypesMap[allTestNames[i]] = runTypes[i];
                                    }
                                    console.log("Built testRunTypesMap:", testRunTypesMap); // Debug log
                                } else {
                                    console.error("Mismatch between all_names and all_types length!");
                                }
                                
                                // Populate run type filters in the UI (uses allRunTypesList populated from unique_types)
                                populateRunTypeFilters();
                            }
                            
                            currentTestNames = data.module_tests.current_names || [];
                            
                            const moduleTests = data.module_tests.as_dict;
                            for (const testName in moduleTests) {
                                cachedData[testName] = moduleTests[testName];
                                if (moduleTests[testName].analysis && moduleTests[testName].analysis.analysisFile) {
                                    plotCache[testName] = moduleTests[testName].analysis.analysisFile;
                                }
                            }
                            
                            if (callback) callback(); // Execute the callback after processing

                        } else {
                            console.error("Invalid data format:", data); // Debug log
                            showError("No module tests found or invalid data format.");
                        }
                    },
                    error: function(xhr, status, error) {
                        console.error("API error:", error); // Debug log
                        hideLoading();
                        showError(`Failed to fetch module tests: ${error}`);
                    }
                });
            }

            // New function to populate run type filter checkboxes
            // This function now uses allRunTypesList which is populated from unique_types
            function populateRunTypeFilters() {
                const container = $('#runTypeFilterContainer');
                container.find('label').remove(); // Clear existing filters
                container.find('span').remove(); // Clear "No run types" message if present

                // *** Add console log here ***
                console.log("Populating run type filters with (from unique_types):", allRunTypesList);

                if (allRunTypesList && allRunTypesList.length > 0) {
                    // Sort the unique types alphabetically for better UI
                    allRunTypesList.sort(); 
                    allRunTypesList.forEach(runType => {
                        if (!runType) return; // Skip empty/null run types

                        const label = $('<label></label>');
                        const checkbox = $('<input type="checkbox">')
                            .attr('value', runType)
                            .prop('checked', selectedRunTypes.has(runType)) // Maintain checked state
                            .on('change', function() {
                                const type = $(this).val();
                                if ($(this).is(':checked')) {
                                    selectedRunTypes.add(type);
                                } else {
                                    selectedRunTypes.delete(type);
                                }
                                console.log("Selected run types:", selectedRunTypes); // Debug log
                                // Re-filter and display
                                currentPage = 1; // Reset to first page
                                calculateVisibleItems();
                                displayCachedOrFetchData();
                            });
                        
                        label.append(checkbox);
                        label.append(` ${runType}`); // Add run type text
                        container.append(label);
                    });
                } else {
                    container.append('<span>No run types available for filtering.</span>');
                }
            }
            
            // Calculate visible items count after filtering
            function calculateVisibleItems() {
                const hideDefaultSessions = $('#hideDefaultSessions').is(':checked');
                visibleItemsCount = 0;
                
                // Start with search results if a query exists, otherwise use all tests
                const testList = (searchQuery && filteredTestNames.length) ? filteredTestNames : allTestNames;
                
                if (testList && isFromSession1 && testRunTypesMap) {
                    for (let i = 0; i < testList.length; i++) {
                        const testName = testList[i];
                        const originalIndex = allTestNames.indexOf(testName); // Use original index for session check
                        const runType = testRunTypesMap[testName];

                        // Apply session filter (only when not searching)
                        if (!searchQuery && hideDefaultSessions && isFromSession1[originalIndex]) {
                            continue;
                        }

                        // Apply run type filter
                        if (selectedRunTypes.size > 0 && !selectedRunTypes.has(runType)) {
                            continue;
                        }
                        
                        // If it passes all filters, count it
                        visibleItemsCount++;
                    }
                }
                
                console.log(`Visible items after all filters: ${visibleItemsCount}`); // Debug log
                
                totalPages = Math.ceil(visibleItemsCount / itemsPerPage);
                if (totalPages === 0) totalPages = 1; // Ensure at least one page even if empty
                console.log(`Total pages after filtering: ${totalPages}`); // Debug log
            }
            
            // Display cached data or fetch new data if not in cache
            function displayCachedOrFetchData() {
                const hideDefaultSessions = $('#hideDefaultSessions').is(':checked');
                const startIdx = (currentPage - 1) * itemsPerPage;
                let visibleItemIndex = 0;
                let needToFetchPage = null;
                
                // Start with search results if a query exists, otherwise use all tests
                const testList = (searchQuery && filteredTestNames.length) ? filteredTestNames : allTestNames;
                
                if (testList && testList.length > 0 && testRunTypesMap) {
                    for (let i = 0; i < testList.length; i++) {
                        const testName = testList[i];
                        const originalIndex = allTestNames.indexOf(testName);
                        const runType = testRunTypesMap[testName];
                        
                        // Apply session filter (only when not searching)
                        if (!searchQuery && hideDefaultSessions && isFromSession1[originalIndex]) {
                            continue;
                        }

                        // Apply run type filter
                        if (selectedRunTypes.size > 0 && !selectedRunTypes.has(runType)) {
                            continue;
                        }
                        
                        // Check if this visible item falls in our current page
                        if (visibleItemIndex >= startIdx && visibleItemIndex < startIdx + itemsPerPage) {
                            if (!cachedData[testName]) {
                                needToFetchPage = Math.floor(originalIndex / 100) + 1;
                                console.log(`Need to fetch page ${needToFetchPage} for test ${testName}`); // Debug log
                                break; // Found a test on this page that needs fetching
                            }
                        }
                        
                        visibleItemIndex++; // Increment only for items passing filters

                        // Optimization: If we've already found enough items for the page, stop checking cache needs
                        if (visibleItemIndex >= startIdx + itemsPerPage) {
                           // break; // Removed this break to ensure needToFetchPage is correctly identified even if later items need fetching.
                        }
                    }
                }
                
                if (needToFetchPage !== null) {
                    apiCurrentPage = needToFetchPage;
                    // Use the helper function to fetch and then display
                    fetchAndProcessPage(apiCurrentPage, () => {
                        filterAndDisplayData();
                        updatePaginationControls();
                    });
                } else {
                    // All required data is in the cache
                    filterAndDisplayData();
                    updatePaginationControls();
                }
            }
            
            // Filter data and display in table
            function filterAndDisplayData() {
                const hideDefaultSessions = $('#hideDefaultSessions').is(':checked');
                const startIdx = (currentPage - 1) * itemsPerPage;
                
                calculateVisibleItems(); // Recalculate counts and total pages based on current filters
                
                displayData = [];
                let visibleItemIndex = 0;
                
                // Start with search results if a query exists, otherwise use all tests
                const testList = (searchQuery && filteredTestNames.length) ? filteredTestNames : allTestNames;
                
                if (testList && testList.length > 0 && testRunTypesMap) {
                    for (let i = 0; i < testList.length; i++) {
                        const testName = testList[i];
                        const originalIndex = allTestNames.indexOf(testName);
                        const runType = testRunTypesMap[testName];
                        
                        // Apply session filter (only when not searching)
                        if (!searchQuery && hideDefaultSessions && isFromSession1[originalIndex]) {
                            continue;
                        }

                        // Apply run type filter
                        if (selectedRunTypes.size > 0 && !selectedRunTypes.has(runType)) {
                            continue;
                        }
                        
                        // Check if this visible item falls in our current page
                        if (visibleItemIndex >= startIdx && visibleItemIndex < startIdx + itemsPerPage) {
                            if (cachedData[testName]) {
                                displayData.push(cachedData[testName]);
                            } else {
                                // This case should ideally be handled by displayCachedOrFetchData,
                                // but log if it happens.
                                console.warn(`Data for visible test ${testName} not found in cache.`);
                            }
                        }
                        
                        visibleItemIndex++; // Increment only for items passing filters

                        // Optimization: Stop iterating if we have filled the page
                        if (displayData.length >= itemsPerPage) {
                            break;
                        }
                    }
                }
                
                console.log(`Display data length after all filters: ${displayData.length}`); // Debug log
                
                const displayStart = visibleItemsCount > 0 ? Math.min(startIdx + 1, visibleItemsCount) : 0;
                const displayEnd = visibleItemsCount > 0 ? Math.min(startIdx + displayData.length, visibleItemsCount) : 0; // Use displayData.length for end count on current page
                
                updatePaginationInfo(
                    displayStart,
                    displayEnd,
                    visibleItemsCount,
                    totalPages
                );
                
                $('#testsTable tbody').empty();
                
                if (displayData.length === 0) {
                    $('#testsTable tbody').html(`<tr><td colspan="8" style="text-align: center;">No tests available with current filters${searchQuery ? ' and search query' : ''}</td></tr>`); // Updated colspan to 8
                } else {
                    displayData.forEach(test => {
                        // ... existing code to extract run, session, analysis, noise data ...
                        const runData = test.run || {}; // Ensure runData is defined
                        const sessionData = test.session || {};
                        const noise = test.noise || {};
                        const analysisData = test.analysis || {};

                        // Extract run number
                        const runMatch = test.test_runName ? test.test_runName.match(/run(\d+)/) : null;
                        const runNumber = runMatch ? parseInt(runMatch[1]) : 0;

                        // Extract test status
                        const testStatus = analysisData.analysisResults ? 
                            Object.values(analysisData.analysisResults)[0] || 'N/A' : 'N/A';

                        // Calculate noise stats
                        const hybrid0SSAValues = [], hybrid0MPAValues = [];
                        const hybrid1SSAValues = [], hybrid1MPAValues = [];
                        Object.entries(noise).forEach(([key, value]) => {
                            if (key.startsWith('H0_SSA')) hybrid0SSAValues.push(value);
                            else if (key.startsWith('H0_MPA')) hybrid0MPAValues.push(value);
                            else if (key.startsWith('H1_SSA')) hybrid1SSAValues.push(value);
                            else if (key.startsWith('H1_MPA')) hybrid1MPAValues.push(value);
                        });
                        const calcAvg = arr => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;
                        const calcMax = arr => arr.length ? Math.max(...arr) : 0;
                        const calcMin = arr => arr.length ? Math.min(...arr) : 0;
                        const noiseStats = { /* ... existing noise calculation ... */ }; // Keep existing noise calc

                        // Construct URLs
                        let logFileUrl = null, resultsUrl = null, monitorDQMUrl = null;
                        if (runData.runFile) {
                            const pathMatch = runData.runFile.match(/([^\/]+\/[^\/]+)$/);
                            if (pathMatch && pathMatch[1]) {
                                const folderName = pathMatch[1].split('/')[0];
                                const basePath = `https://cmstkita.web.cern.ch/Pisa/TBPS/navigator_eos.php/${pathMatch[1]}`;
                                logFileUrl = `https://cmstkita.web.cern.ch/Pisa/TBPS/log.html?logfile=${basePath}/${folderName}.log`;
                                resultsUrl = `https://cmstkita.web.cern.ch/Pisa/TBPS/root.html?file=${basePath}/Results.root`;
                                monitorDQMUrl = `https://cmstkita.web.cern.ch/Pisa/TBPS/root.html?file=${basePath}/MonitorDQM.root`;
                            }
                        }

                        // Create row
                        const row = $('<tr></tr>');
                        if (test.moduleTestName === selectedTestName) row.addClass('selected-test');

                        // Checkbox column
                        const checkboxCell = $('<td></td>');
                        const checkbox = $('<input type="checkbox" class="test-checkbox">')
                            .data('test-name', test.moduleTestName)
                            .on('change', function() { /* ... existing change handler ... */ });
                        checkboxCell.append(checkbox);
                        row.append(checkboxCell);

                        // Test name column
                        const testCell = $('<td></td>');
                        const testNameSpan = $('<span></span>')
                            .addClass('module-name')
                            .text(test.moduleTestName)
                            .data('test-name', test.moduleTestName)
                            .on('click', function() { /* ... existing click handler ... */ });
                        testCell.append(testNameSpan);
                        // if (testStatus.toLowerCase() === 'pass') testCell.append($('<span></span>').addClass('pass-badge').text('PASS'));
                        // else if (testStatus.toLowerCase() === 'failed') testCell.append($('<span></span>').addClass('fail-badge').text('FAIL'));
                        // Temperature info
                        if (analysisData.moduleTempStart !== undefined || analysisData.moduleTempStop !== undefined) {
                            const startTemp = analysisData.moduleTempStart !== undefined ? parseFloat(analysisData.moduleTempStart).toFixed(2) + ' °C' : 'N/A';
                            const stopTemp = analysisData.moduleTempStop !== undefined ? parseFloat(analysisData.moduleTempStop).toFixed(2) + ' °C' : 'N/A';
                            testCell.append($('<div></div>').addClass('temperature-info').html(`<span class="temperature-label">Temp:</span> <span class="temperature-value">${startTemp} to ${stopTemp}</span>`));
                        } else {
                            testCell.append($('<div></div>').addClass('temperature-info').html('<span class="temperature-label">Temp:</span> <span class="temperature-value-unknown">unknown</span>'));
                        }
                        row.append(testCell);

                        // Module column
                        const moduleCell = $('<td></td>');
                        if (test.moduleName) {
                            moduleCell.append($('<a></a>').addClass('module-link').attr('href', `module_results.html?module=${encodeURIComponent(test.moduleName)}`).text(test.moduleName));
                        } else {
                            moduleCell.text('N/A');
                        }
                        row.append(moduleCell);

                        // Run column
                        const runCell = $('<td></td>');
                        const runInfo = $('<div></div>').addClass('run-info');
                        runInfo.append($('<span></span>').addClass('run-number').text(`#${runNumber}`));
                        if (runData.runDate) {
                            const date = new Date(runData.runDate);
                            runInfo.append($('<span></span>').addClass('run-date').text(date.toLocaleDateString('en-GB') + ' ' + date.toLocaleTimeString('en-GB')));
                        }
                        if (resultsUrl) runInfo.append($('<span></span>').addClass('run-results').html(`<a href="${resultsUrl}" target="_blank">Read ROOT File</a>`));
                        if (monitorDQMUrl) runInfo.append($('<span></span>').addClass('run-results').html(`<a href="${monitorDQMUrl}" target="_blank">Read DQM File</a>`));
                        if (logFileUrl) runInfo.append($('<span></span>').addClass('run-results').html(`<a href="${logFileUrl}" target="_blank">Read Log File</a>`));
                                                // Add runType here using the map
                                                const currentRunType = testRunTypesMap[test.moduleTestName];
                        if (currentRunType) { 
                             runInfo.append($('<span></span>').addClass('run-type').text(`Type: ${currentRunType}`));
                        }
                        runCell.append(runInfo);
                        row.append(runCell);

                        // Session column
                        const sessionCell = $('<td></td>');
                        const sessionInfo = $('<div></div>').addClass('session-info');
                        if (sessionData.operator) sessionInfo.append($('<span></span>').addClass('session-operator').text(`Operator: ${sessionData.operator}`));
                        if (sessionData.description) sessionInfo.append($('<span></span>').addClass('session-description').text(sessionData.description));
                        if (sessionData.sessionName) sessionInfo.append($('<span></span>').addClass('session-name').text(`Session: ${sessionData.sessionName}`));
                        sessionCell.append(sessionInfo);
                        row.append(sessionCell);

                        // Noise Stats column (ensure colspan=8 in header/footer if adding this)
                        const noiseStatsCell = $('<td></td>');
                        if (Object.keys(noise).length > 0) {
                            // ... existing noise stats HTML generation ...
                             const hasSSA = hybrid0SSAValues.length > 0 || hybrid1SSAValues.length > 0;
                             const hasMPA = hybrid0MPAValues.length > 0 || hybrid1MPAValues.length > 0;
                             let noiseHtml = '<div class="noise-stats">';
                             if (hasSSA) noiseHtml += `<div class="noise-component"><div class="noise-component-title">SSA:</div><div class="noise-stat-row">Avg: ${calcAvg([...hybrid0SSAValues, ...hybrid1SSAValues]).toFixed(3)}</div><div class="noise-stat-row">Max: ${calcMax([...hybrid0SSAValues, ...hybrid1SSAValues]).toFixed(3)}</div><div class="noise-stat-row">Min: ${calcMin([...hybrid0SSAValues, ...hybrid1SSAValues]).toFixed(3)}</div></div>`;
                             if (hasMPA) noiseHtml += `<div class="noise-component"><div class="noise-component-title">MPA:</div><div class="noise-stat-row">Avg: ${calcAvg([...hybrid0MPAValues, ...hybrid1MPAValues]).toFixed(3)}</div><div class="noise-stat-row">Max: ${calcMax([...hybrid0MPAValues, ...hybrid1MPAValues]).toFixed(3)}</div><div class="noise-stat-row">Min: ${calcMin([...hybrid0MPAValues, ...hybrid1MPAValues]).toFixed(3)}</div></div>`;
                             noiseHtml += '</div>';
                             noiseStatsCell.html(noiseHtml);
                        } else {
                            noiseStatsCell.text('No noise data');
                        }
                        row.append(noiseStatsCell); // Append noise cell

                        // Analysis column
                        const analysisCell = $('<td></td>');
                        if (analysisData.analysisVersion) analysisCell.append($('<div></div>').text(`Version: ${analysisData.analysisVersion}`));
                        if (analysisData.analysisFile) analysisCell.append($('<div></div>').html(`<a href="${analysisData.analysisFile}" target="_blank">View Analysis</a>`));
                        row.append(analysisCell);

                        // Plots column
                        const plotsCell = $('<td></td>');
                        plotsCell.append($('<div></div>').addClass('plots-container'));
                        row.append(plotsCell);
                        
                        $('#testsTable tbody').append(row);
                    });
                }
            }
            
            // Select a test and display its plot
            function selectTest(testName, rowElement) {
                $('.selected-test').removeClass('selected-test');
                rowElement.addClass('selected-test');
                selectedTestName = testName;
                // displayPlotForSelectedTest(); // Plot display is now triggered by checkbox
            }
            
            // Clear plots for a row
            function clearPlots(row) {
                const plotsContainer = row.find('.plots-container');
                plotsContainer.empty();
            }

            // Display plots for a specific test
            function displayPlotsForTest(testName, row) {
                const plotsContainer = row.find('.plots-container');
                plotsContainer.empty();
                const analysisFile = plotCache[testName];
                if (!analysisFile) {
                    plotsContainer.html('<p>No plot data available</p>');
                    return;
                }
                displayPlots(testName, analysisFile, plotsContainer);
            }

            function displayPlots(testName, analysisFile, plotsContainer) {
                $('.plot-type-select').each(function() {
                    const plotType = $(this).val();
                    const plotName = $(this).find('option:selected').text();
                    const plotUrl = `${analysisFile}${plotType}.png`;
                    const plotColumn = $('<div class="plot-column"></div>').attr('data-plot-type', plotType);
                    plotColumn.html(`
                        <div class="plot-header">${plotName}</div>
                        <img class="plot-image" src="${plotUrl}" alt="${testName} - ${plotName}" 
                             onerror="this.onerror=null;this.src='';this.alt='Plot not available';this.style.height='200px';this.style.width='300px';this.style.backgroundColor='#f5f5f5';this.style.display='flex';this.style.alignItems='center';this.style.justifyContent='center';">
                    `);
                    plotsContainer.append(plotColumn);
                });
            }
            
            // Display the plot for the currently selected test (potentially unused now)
            function displayPlotForSelectedTest() {
                // ... (implementation remains, but might not be called) ...
            }
            
            // Update pagination controls
            function updatePaginationControls() {
                $('#prevPage').prop('disabled', currentPage <= 1);
                $('#nextPage').prop('disabled', currentPage >= totalPages);
                // Ensure totalPages is at least 1 for display
                const displayTotalPages = Math.max(totalPages, 1);
                $('#currentPageInfo').text(`Page ${currentPage} of ${displayTotalPages}`);
            }
            
            // Update pagination information
            function updatePaginationInfo(start, end, total, pages) {
                 // Ensure totalPages is at least 1 for display
                const displayTotalPages = Math.max(pages, 1);
                $('#paginationSummary').text(`Showing ${start}-${end} of ${total} entries`);
                $('#currentPageInfo').text(`Page ${currentPage} of ${displayTotalPages}`);
                $('#prevPage').prop('disabled', currentPage <= 1);
                $('#nextPage').prop('disabled', currentPage >= pages); // Use actual 'pages' for disabling logic
            }
            
            // Show loading indicator
            function showLoading() {
                $('#loading').show();
                $('#content').hide();
                $('#error').hide();
            }
            
            // Hide loading indicator
            function hideLoading() {
                $('#loading').hide();
            }
            
            // Show error message
            function showError(message) {
                $('#error').text(message).show();
                $('#loading').hide();
            }

            function updateAllPlots() {
                $('.test-checkbox:checked').each(function() {
                    const row = $(this).closest('tr');
                    const testName = $(this).data('test-name');
                    displayPlotsForTest(testName, row);
                });
            }

        });
    </script>
</body>
</html>
